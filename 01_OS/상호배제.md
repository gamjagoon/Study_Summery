### 1. 상호배제의 개념

+ **개념** : 병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법이다.*
  - <b>임계자원 : </b>두 프로세스가 동시에 사용할수 없는 공유자원
  - <b>임계영역 : </b>임계 자원에 접근하고 실행하는 프로그램 코드부분
- **임계영역에의 동작조건**
  1. 두 프로세스는 동시에 공유 자원에 진입할 수 업다.
  2. 프로세스의 속도나 프로세서 수에 영향을 받지 않는다.
  3. 공유 자원을 사용하는 프로세스만 다른 프로세스를 차단할 수 있다.
  4. 프로세스가 공유 자원을 사용하려고 너무 오래 기다려서는 안 된다.

### 2. 임계 영역 의 세가지 조건

* **상호배제** : 어떤 프로세스가 임계 영역에서 작업 중이면 다른 프로세스는 임계역역으로 들어갈 수 없다.
* **진행** : 임계 영역에 프로세스가 없는 상태에서 여러 프로세스가 들어가려고 할 떄는 어떤 프로세스가 들어갈지 적절히 결정해야 한다.
* **한정대기** : 다른 프로세스가 임계 영역을 무한정 기다리는 상활을 방지하려면 임계 영역에 한번 들어갔던 프로세스는 다음에 임계 영역에 다시 들어갈 때 제한을 둔다.

### 3. 생산자 소비자 문제와 상호배제 해결 초기 시도

- 생산자는 소비자에게 데이터를 전송할 때, 데이터를 소비자가 받을 준비가 되면 데이터를 전송하고 소비자가 계속 처리하지 못하면 대기해야 한다 이때 생산자와 소비자가 불필요하게 공회전하지 않도록 데이터를 전송하는 방법이 필요한데, 이는 임시 기억장소인 버퍼를 도입하여 해결한다.

1. **공유데이터 선언**

    ```c++
    #define BUFFER_SIZE 10 //버퍼 크기
    typedef struct {
        DATA data;
    }item;
    item buffer[BUFFER_SIZE];
    int in = 0;
    int out = 0;
    int counter = 0;
    ```
> counter 은 원소가 추가될때 1증가하고 삭제할 떄만다 1씩 감소한다.
> in 과 out은 입력하고 출력할 공산을 가리킨다.

2. **생산자 소비자 프로세스**

    생산자 프로세스

    ```c
      item nextProduced;
    
    while(true){
        while(counter == BUFFER_SIZE);//버퍼가 가득 차 아무일도 하지 않음
        buffer[in] = nexttProduced;
        in = (in + 1) % BUFFER_SIZE;
        counter++;
    }
    ```

   소비자 프로세스

    ```c
    item nextConsumer;
    
    while(true){
        while(counter == 0);//버퍼가 비어 아무일도 하지 않음
        buffer[in] = nexttProduced;
        in = (in + 1) % BUFFER_SIZE;
        counter++;
    }
    ```

3. **생산자와 소비자의 동시 수행 예**

   ```c
   T1 : 생산자가 register1 = counter 수행 (register1 = 5);
   T2 : 생산자가 register1 = register1 + 1 수행(register1= 6);
   T3 : 소비자가 register2 = counter 수행 (register2 = 5);
   T4 : 소비자가 register2 = register2 - 1 수행(register2 = 4);
   ```

   위처럼 **register1**과 **register2** 은 **경쟁상태**에 있다고 볼수있다. 이는 데이터의 결과를 보장할수 없다.